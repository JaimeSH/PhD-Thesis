\chapter{Implementacion}
\label{chapter:implementation}

El siguiente conjunto de secciones describen la implementacion del metodo
propuesto segun las explicaciones presentadas en el Capitulo
\ref{chapter:proposed-method}. La implementacion propuesta utiliza un software
de simulacion como el mostrado en \cite{} (\url{}), este software de simulacion esta
programado en Unity con codigo fuente en lenguaje C\# de Visual Studio.

\section{Codificando los diccionarios de piezas}
\label{section:piece_dictionary}

La primera parte que se desarrollo para poder integrar el listado de piezas al
sistema de generacion fue decir la manera en como se establecerian las
diferentes piezas como las mostradas en la figura \ref{figure:game-basic-blocks}
del Capitulo \ref{chapter:proposed-method}, para esto se tomaron enncuenta
varias posibilidades, la primera, como se explica en la seccion
\ref{subsection:objectorientedidea} se buscaba ordenar las diferentes piezas
como diccionarios que contuvieran una o mas referencias a las piezas que
integraban cada entrada del diccionario, para esto las primeras 11 posiciones
eran elementos individuales uno para cada pieza como el mostrado en la figura
\ref{code:dic_individual_piece}, en el codigo se aprecia la manera en como se
designaba una pieza del juego, para poder trabajar de manera dinamica para poder
agregar mas compuestos segun fuese necesario se utilizaban dos diccionarios
extra, estos contenian los datos de los tipos de materiales posibles y la
informacion de los tama√±os de las piezas, de esta manera en caso de tener mas de
una pieza en algun punto del diccionario era posible modificar el valor de
offset de cada una de las piezas calculando la distancia del punto central de
cada pieza al centro de todo el conjunto.

\begin{listing}[t]
  \begin{minted}[frame=lines, framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,linenos]{python}
    BLOCKS = {
      0: [
          {'type': BLOCK_TYPE['Circle'],
          'material': BLOCK_MATERIAL['wood'],
          'offset': [0, 0, 0] # x, y, z - Calculated from the center of the figure
          }]
    }

    BLOCK_TYPE = {
    'Circle': {'height': 72, 'lenght': 72},
    'RectTiny': {'height': 22, 'lenght': 42},
    'RectSmall': {'height': 22, 'lenght': 42},
    'RectBig': {'height': 22, 'lenght': 42},
    'RectMedium': {'height': 22, 'lenght': 42},
    'RectFat': {'height': 42, 'lenght': 82},
    'SquareTiny': {'height': 22, 'lenght': 22},
    'SquareSmall': {'height': 42, 'lenght': 42},
    'Triangle': {'height': 72, 'lenght': 72},
    'TriangleHole': {'height': 82, 'lenght': 82},
    'SquareHole': {'height': 82, 'lenght': 82}
    }

    BLOCK_MATERIAL = {
        'wood': 0,
        'stone': 1,
        'ice': 2
    }
  \end{minted}
  \caption{Ejemplo de diccionario con un solo elemento}
  \label{code:dic_individual_piece}
\end{listing}

De esta manera como se explico anteriormente era mas sencillo crear compuestos,
sin embargo, la desventaja que conyevaba utilizar este metodo era que no podiar
realizar modificaciones a las restricciones de las piezas, es decir, en caso de
querer evitar que un conjunto de piezas con determinados materiales no fuesen
generados no se tenia la facilidad de impedir este tipo de combinaciones.

En luz de esta informacion se opto por utilizar el metodo en base a clases
mencionado en la seccion \ref{subsection:classorientedidea}, el codigo
\ref{code:dic_individual_piece} muestra la nueva estructura utilizada segun el
diagrama de clases presentado en la figura \ref{figure:pieces-class-diagram},
deacuerdo a el diagrama presentado una clase base con las operaciones y
propiedades necesarias funcionaria como una clase \textit{padre} para las clases
de piezas particulares, de esta manera los individuos se representaran como un
conjunto de referencias a las clases que deben de ser generadas para la
composicion de niveles, sin embargo, esta manera de representar a los individuos
no contempla las restricciones que pueden ser definidas para la combinacion de
piezas-materiales, debido a esto se opto por genar una lista global que
mantuviera un record de las restricciones aplicadas en el sistema, y al momento
de generar cada reinstanciacion de clase para los indiciduos esta informacion se
pasara a las clases segun fuese requerido, en el codigo se presenta una variable
con el nombre \textit{mat}, esta variable tomara una lista de 3 valores que
define si alguno o algunos de los materiales no puede ser utilizado al momento
de asignar las clases a los individuos, al momento de encontrar una pieza que de
la coincidencia no puede ser utilizada con ningun material se eliminaran los
datos de la pieza generada y se pedira al sistema genere otra de manera aleatoria.

\begin{listing}[ht]
  \begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,linenos]{python}
    class Circle(Piece):
      def __init__(self, mat, x=0, y=0, r=0):
          self.Name = "Circle"
          self.Height = 75
          self.Width = 75
          Piece.__init__(self, x, y, r, mat)
          self.update_values()
  \end{minted}
  \caption{Ejemplo de estructura de las clases hija que heredan de la principal}
  \label{code:dic_individual_piece}
\end{listing}


\section{Creacion de compuestos}
\label{section:composite_creation}

Una vez definidas las clases particulares que controlaran la informacion de las
piezas en el algoritmo se procede a definir la manera en como se entregaran y
controlaran los diferentes compuestos de piezas, para terminos mas simples los
compuestos son grupos de una o mas piezas y se mostraran a manera de diccionario
de listas como se muestra en el codigo \ref{code:dic_composites}, de esta manera
cada entrada en el diccionario tiene por nombre o apuntador el valor posicion
segun se fueron agregando al diccionario mientras que el contenido es una lista
con tuplas donde se estipula la informacion pertinente de cada pieza en el
compuesto, un ejemplo claro es el elemento en la posicion \textit{9} el cual
cuenta con 3 piezas que muestran los valores de offset medida desde el centro
del compuesto visto graficamente en el juego, esta lista se utiliza para
mantener un control de los compuestos que se pueden ir agregando durante la
ejecucion del algoritmo, de tal manera que las clases auxiliares de
\textit{Composite} creadas haran referencia a una o mas piezas segun la lista se
haya proporcionado al crear el compuesto.

\begin{listing}[ht]
  \begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,linenos]{python}
    Composites = {
      0: [("RectTiny", 0, 0, 0, "wood")],
      1: [("RectSmall", 0, 0, 0, "wood")],
      2: [("RectMedium", 0, 0, 0, "wood")],
      3: [("RectBig", 0, 0, 0, "wood")],
      4: [("RectFat", 0, 0, 0, "wood")],
      5: [("SquareSmall", 0, 0, 0, "wood")],
      6: [("SquareHole", 0, 0, 0, "wood")],
      7: [("Circle", 0, 0, 0, "wood")],
      8: [("TriangleHole", 0, 0, 0, "wood")],
      9: [("RectBig", 100, 5, -27, "wood"), ("RectBig", -100, 5, 27, "wood"), ...
            ...("RectSmall", 0, 0, 90, "wood")]
    } 
  \end{minted}
  \caption{Diccionario con los compuestos existentes}
  \label{code:dic_composites}
\end{listing}

\section{Definicion de clase auxiliar de individuo}
\label{section:definition_of_clases}

Mediante el uso de la clase de composite se tiene un mejor control de los genes
que conformaran cada individuo de la poblacion, una vez que se tiene este
aspecto controlado el siguiente paso es el de crear programar la clase que
llevara el control de los cromosomas de un individuo, siendo los cromosomas los
compuestos asignados a cada individuo particular, de tal manera que un individuo
dentro de la informacion de cromosomas hara referencia a otra lista de
compuestos, la manera en como un \textit{Individuo} relaciona los compuestos es
mediante el uso de la linea de codigo:

\begin{minted}{python}
  chromosome_objects = [Composite(Composites[composite]) for composite in self.chromosome]
\end{minted}

Mediante esta linea de codigo se indica que se debera de crar una lista en donde
cada elemento sera una instancia de un compuesto asignado al individuo, de esta
manera si se requiere modificar la posicion o materiales de un compuesto
particular en el individuo es posible hacerlo desde la clase de
\textit{individuo}, de igual manera esta clase tiene como funciones principales
como se muestran en el diagrama de clase de la figura
\ref{figure:individual-class-diagram} realizar los calculos de fitness y generar

\section{Generacion de individuos}
\label{section:ind_generation}

Una vez definida la manera de controlar las clases el paso siguiente es el de
comenzar con la generacion de ls individuos de la poblacion, para poder lograr
esto se creo una linea de codigo en la cual los puntos necesarios para la
generacion de los individuos se entregan totalmente, esta linea de codigo en
cuestion es como sigue: 

\begin{minted}{python}
  pop = [Individual(chromosome = get_random_chrom(ind_pieces), ..
    ..mask = create_new_mask(ind_pieces)) for i in range(population)]
\end{minted}

Mediante el uso de esta linea de codigo se le indica al sistema que se requiere
una lista que representara a los individuos de la poblacion, cada elemento de
esta lista sera una instancia independiente de la clase \textit{Individual},
para generar esta instancia de clase es requerido dos valores siendo estos
primero una lista de valores numericos que representan cuales piezas se
asignaran a los individuos, para generar esta lista se utiliza una funcion como
se muestra en el codigo \ref{code:get_random_chrom}, el segundo dato requerido
es una segunda lista que denota una mascara mediante la cual las piezas
asignadas seran acomodadas al momento de generar los archivos de simulacion,
finalmente la ultima seccion del codigo - \textit{for i in range(population)} -
denota que el proceso se debera de repetir una cierta cantidad de veces, es
decir que pada cada individuo se generara una instancia con valores diferentes a
los anteriores, la cantidad de vences que se debera de repetir depende de la
cantidad de individuos con los que se quiere estar trabajando en el algoritmo en
el caso de las pruebas realizadas se utilizo un totoal de 10 individuos lo que
significa que la lista \textit{pop} generada consta de 10 instancias diferentes
de la clase \textit{Individual}. 

Para la genracion de la lista de piezas o cromosomas asignados a un individuo
mostrada en la parte (1) del codigo en \ref{code:get_random_chrom}, aqui el
valor que se recive denota la cantidad de piezas o compuestos que se deberan de
asignar en la lista para el individuo, para asignar estos valores primero se
obtine un numero aleatorio que va desde \textit{0} hasta la cantidad de piezas o
compuestos presentes en la lista menos una unidad para evitar errores de
posicionamiento de lista, posteriormente se revisa si la pieza seleccionada
puede ser utilizada almenos en una combinacion dentro de la generacion, en caso
de que no puede ser utilizada se obtiene otra y de igual manera se revisa, en
caso de poder ser utilizada se agrega a la lista y avanza un contador para saber
cuando se llegue al limite de piezas posibles de usar, finalmente se entrega la
lista de piezas para la generacion de la instancia de clase. Para la generacion
de la mascara de acomodo de piezas se utiliza la seccion de codigo mostrado en
la parte (2), en esta parte lo que se realiza es que se revisa la cantidad de
compuestos que se pueden utilizar como en la parte anterior, este valor se
utiliza posteriormente para generar una lista aleatoria, la lista que se genera
tiene un total de 7 posiciones que denotan 7 divisiones que se realizan en el
area de un nivel para el acomodo de las piezas, mediante el uso del valor de
piezas en cada individuo se realiza una aleatorizacion de numeros desde
\textit{0} hasta la cantidad maxima de piezas, una vez se obtienen estos valores
aleatorios se revisa si la suma de estos da la cantidad de piezas en el
individuo, en caso de que no sea asi se repite el proceso, en caso de que si se
cumpla entonces la lista se regresa para la creacion de la instancia de clase.

\begin{listing}[ht]
  \begin{minted}[frame=lines, framesep=2mm, baselinestretch=1.2, fontsize=\footnotesize, linenos]{python}
 (1)  def get_random_chrom(sl):
        asl = 0
        chrom = []
        while asl < sl:
            prop = random.randint(0, len(Composites)-1)
            if clases[Composites[prop][0][0]].Valid == True:
                chrom.append(prop)
                asl += 1
        #random.randint(0,len(Composites)-1) for p in range(ind_pieces)
        return chrom

 (2)  def create_new_mask(pieces):
        div_list =[]
        while True:
            div_list = [random.randint(0, pieces-1) for col in range(7)]
            if sum(div_list) == pieces:
                break
          
        return div_list
  \end{minted}
  \caption{Codigo de asignacion de cromosomas(piezas)[1] y codigo para generar mascaras [2]}
  \label{code:get_random_chrom}
\end{listing}